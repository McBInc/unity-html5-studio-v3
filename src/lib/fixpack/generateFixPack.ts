export type ScanResponse = {
  kind: string;
  quick_score: number;
  compression?: { brotli_present: boolean; gzip_present: boolean };
  memory_settings_detected_bytes?: number[];
  files?: { name: string; size_bytes: number; sha256: string }[];
  hosting_checks?: { check: string; severity: "info" | "medium" | "high" }[];
  scanned_at?: string;
};

export type FixPack = {
  vercelJson: string;
  netlifyHeaders: string;
  nginxConf: string;
  htaccess: string;
  readme: string;
};

type Brand = {
  productName: string; // e.g. "Unity → HTML5 Studio"
  website: string;     // e.g. "https://yourdomain.com" (can be your Vercel URL for now)
};

export function generateFixPack(scan: ScanResponse, brand: Brand): FixPack {
  const brotli = !!scan.compression?.brotli_present;
  const gzip = !!scan.compression?.gzip_present;

  const vercelJson = generateVercelJson({ brotli, gzip });
  const netlifyHeaders = generateNetlifyHeaders({ brotli, gzip, brand });
  const nginxConf = generateNginxConf({ brotli, gzip, brand });
  const htaccess = generateHtaccess({ brotli, gzip, brand });
  const readme = generateReadme({ brotli, gzip, scan, brand });

  return { vercelJson, netlifyHeaders, nginxConf, htaccess, readme };
}

/**
 * Vercel notes:
 * - Unity often references precompressed assets like *.wasm.br, *.data.br, *.js.br
 * - Vercel must send Content-Encoding and correct Content-Type for these.
 * - Also recommend caching Build/* strongly, and not caching index.html.
 *
 * Keep JSON strictly valid (no comments).
 */
function generateVercelJson(opts: { brotli: boolean; gzip: boolean }): string {
  const headers: any[] = [];

  // Cache: Build artifacts
  headers.push({
    source: "/Build/(.*)",
    headers: [{ key: "Cache-Control", value: "public, max-age=31536000, immutable" }],
  });

  // Index should not be aggressively cached
  headers.push({
    source: "/",
    headers: [{ key: "Cache-Control", value: "no-cache" }],
  });

  // wasm MIME (both plain and precompressed)
  headers.push({
    source: "/(.*)\\.wasm",
    headers: [{ key: "Content-Type", value: "application/wasm" }],
  });
  headers.push({
    source: "/(.*)\\.wasm\\.(br|gz)",
    headers: [{ key: "Content-Type", value: "application/wasm" }],
  });

  // Brotli
  if (opts.brotli) {
    // Apply encoding for *.br
    headers.push({
      source: "/(.*)\\.br",
      headers: [{ key: "Content-Encoding", value: "br" }],
    });

    // Better content types for common Unity artifacts
    headers.push({
      source: "/(.*)\\.js\\.br",
      headers: [{ key: "Content-Type", value: "application/javascript; charset=utf-8" }],
    });
    headers.push({
      source: "/(.*)\\.data\\.br",
      headers: [{ key: "Content-Type", value: "application/octet-stream" }],
    });
    headers.push({
      source: "/(.*)\\.json\\.br",
      headers: [{ key: "Content-Type", value: "application/json; charset=utf-8" }],
    });
  }

  // Gzip
  if (opts.gzip) {
    headers.push({
      source: "/(.*)\\.gz",
      headers: [{ key: "Content-Encoding", value: "gzip" }],
    });

    headers.push({
      source: "/(.*)\\.js\\.gz",
      headers: [{ key: "Content-Type", value: "application/javascript; charset=utf-8" }],
    });
    headers.push({
      source: "/(.*)\\.data\\.gz",
      headers: [{ key: "Content-Type", value: "application/octet-stream" }],
    });
    headers.push({
      source: "/(.*)\\.json\\.gz",
      headers: [{ key: "Content-Type", value: "application/json; charset=utf-8" }],
    });
  }

  const out = { headers };
  return JSON.stringify(out, null, 2);
}

function generateNetlifyHeaders(opts: { brotli: boolean; gzip: boolean; brand: Brand }): string {
  const lines: string[] = [];
  lines.push(`# Generated by ${opts.brand.productName}`);
  lines.push(`# ${opts.brand.website}`);
  lines.push("");

  // Cache Build folder aggressively (Unity typically places big files there)
  lines.push(`/Build/*`);
  lines.push(`  Cache-Control: public, max-age=31536000, immutable`);
  lines.push("");

  // Don't cache entry html too aggressively
  lines.push(`/`);
  lines.push(`  Cache-Control: no-cache`);
  lines.push("");

  // wasm mime
  lines.push(`/*.wasm`);
  lines.push(`  Content-Type: application/wasm`);
  lines.push("");

  // Precompressed wasm
  lines.push(`/*.wasm.br`);
  lines.push(`  Content-Type: application/wasm`);
  if (opts.brotli) lines.push(`  Content-Encoding: br`);
  lines.push("");

  lines.push(`/*.wasm.gz`);
  lines.push(`  Content-Type: application/wasm`);
  if (opts.gzip) lines.push(`  Content-Encoding: gzip`);
  lines.push("");

  if (opts.brotli) {
    lines.push(`/*.br`);
    lines.push(`  Content-Encoding: br`);
    lines.push("");
  }

  if (opts.gzip) {
    lines.push(`/*.gz`);
    lines.push(`  Content-Encoding: gzip`);
    lines.push("");
  }

  return lines.join("\n");
}

function generateNginxConf(opts: { brotli: boolean; gzip: boolean; brand: Brand }): string {
  const lines: string[] = [];

  lines.push(`# Generated by ${opts.brand.productName}`);
  lines.push(`# ${opts.brand.website}`);
  lines.push(`# Purpose: correct encodings + wasm MIME + caching for Unity WebGL builds`);
  lines.push("");

  lines.push(`server {`);
  lines.push(`  # ... your server_name / root / SSL config here ...`);
  lines.push("");
  lines.push(`  # wasm mime`);
  lines.push(`  types { application/wasm wasm; }`);
  lines.push("");

  lines.push(`  # Cache build artifacts`);
  lines.push(`  location ^~ /Build/ {`);
  lines.push(`    add_header Cache-Control "public, max-age=31536000, immutable";`);
  lines.push(`  }`);
  lines.push("");

  lines.push(`  # Don't cache entrypoint aggressively`);
  lines.push(`  location = / {`);
  lines.push(`    add_header Cache-Control "no-cache";`);
  lines.push(`  }`);
  lines.push("");

  if (opts.brotli) {
    lines.push(`  # If you have ngx_brotli installed, consider: brotli_static on;`);
    lines.push(`  location ~* \\.br$ {`);
    lines.push(`    add_header Content-Encoding br;`);
    lines.push(`    # Content-Type is inferred from the underlying file extension (best handled by explicit locations below).`);
    lines.push(`  }`);
    lines.push("");
    lines.push(`  location ~* \\.wasm\\.br$ { add_header Content-Type application/wasm; add_header Content-Encoding br; }`);
    lines.push(`  location ~* \\.js\\.br$   { add_header Content-Type application/javascript; add_header Content-Encoding br; }`);
    lines.push(`  location ~* \\.json\\.br$ { add_header Content-Type application/json; add_header Content-Encoding br; }`);
    lines.push(`  location ~* \\.data\\.br$ { add_header Content-Type application/octet-stream; add_header Content-Encoding br; }`);
    lines.push("");
  }

  if (opts.gzip) {
    lines.push(`  # If you have gzip_static module, consider: gzip_static on;`);
    lines.push(`  location ~* \\.gz$ {`);
    lines.push(`    add_header Content-Encoding gzip;`);
    lines.push(`  }`);
    lines.push("");
    lines.push(`  location ~* \\.wasm\\.gz$ { add_header Content-Type application/wasm; add_header Content-Encoding gzip; }`);
    lines.push(`  location ~* \\.js\\.gz$   { add_header Content-Type application/javascript; add_header Content-Encoding gzip; }`);
    lines.push(`  location ~* \\.json\\.gz$ { add_header Content-Type application/json; add_header Content-Encoding gzip; }`);
    lines.push(`  location ~* \\.data\\.gz$ { add_header Content-Type application/octet-stream; add_header Content-Encoding gzip; }`);
    lines.push("");
  }

  lines.push(`  # Plain wasm (if not precompressed)`);
  lines.push(`  location ~* \\.wasm$ { add_header Content-Type application/wasm; }`);
  lines.push(`}`);
  lines.push("");

  return lines.join("\n");
}

function generateHtaccess(opts: { brotli: boolean; gzip: boolean; brand: Brand }): string {
  const lines: string[] = [];
  lines.push(`# Generated by ${opts.brand.productName}`);
  lines.push(`# ${opts.brand.website}`);
  lines.push(`# Apache/.htaccess hints for Unity WebGL hosting`);
  lines.push("");

  // wasm mime
  lines.push(`# wasm mime`);
  lines.push(`AddType application/wasm .wasm`);
  lines.push(`AddType application/octet-stream .data`);
  lines.push(`AddType application/javascript .js`);
  lines.push(`AddType application/json .json`);
  lines.push("");

  if (opts.brotli) {
    lines.push(`# Brotli precompressed assets`);
    lines.push(`AddEncoding br .br`);
    lines.push("");
  }

  if (opts.gzip) {
    lines.push(`# Gzip precompressed assets`);
    lines.push(`AddEncoding gzip .gz`);
    lines.push("");
  }

  lines.push(`# Cache Build folder strongly`);
  lines.push(`<IfModule mod_headers.c>`);
  lines.push(`  <LocationMatch "^/Build/">`);
  lines.push(`    Header set Cache-Control "public, max-age=31536000, immutable"`);
  lines.push(`  </LocationMatch>`);
  lines.push(`  <LocationMatch "^/$">`);
  lines.push(`    Header set Cache-Control "no-cache"`);
  lines.push(`  </LocationMatch>`);
  lines.push(`</IfModule>`);
  lines.push("");

  return lines.join("\n");
}

function generateReadme(opts: { brotli: boolean; gzip: boolean; scan: ScanResponse; brand: Brand }): string {
  const lines: string[] = [];
  lines.push(`# WebGL Hosting Fix Pack`);
  lines.push(`Generated by **${opts.brand.productName}**`);
  lines.push(`${opts.brand.website}`);
  lines.push("");
  lines.push(`## What this pack does`);
  lines.push(`This pack helps prevent common Unity WebGL hosting failures by configuring:`);
  lines.push(`- Correct **Content-Encoding** for precompressed assets (.br / .gz)`);
  lines.push(`- Correct **MIME type** for WebAssembly (.wasm)`);
  lines.push(`- Recommended **caching** headers for /Build assets`);
  lines.push("");
  lines.push(`## Your scan summary`);
  lines.push(`- Brotli detected: **${opts.brotli ? "Yes" : "No"}**`);
  lines.push(`- Gzip detected: **${opts.gzip ? "Yes" : "No"}**`);
  lines.push(`- Quick score: **${opts.scan.quick_score}/100**`);
  lines.push(`- Memory hints found: **${opts.scan.memory_settings_detected_bytes?.length ? "Yes" : "No"}**`);
  lines.push("");

  lines.push(`## Choose your hosting platform`);
  lines.push(`### Vercel`);
  lines.push(`1. Copy \`vercel.json\` into your project root`);
  lines.push(`2. Deploy`);
  lines.push(`3. Verify that requests for *.wasm.br return headers:`);
  lines.push(`   - Content-Encoding: br`);
  lines.push(`   - Content-Type: application/wasm`);
  lines.push("");

  lines.push(`### Netlify`);
  lines.push(`1. Put the included \`_headers\` file in your publish directory (or repo root if it’s your publish dir).`);
  lines.push(`2. Deploy`);
  lines.push("");

  lines.push(`### Nginx`);
  lines.push(`1. Merge rules from \`nginx.conf\` into your server block`);
  lines.push(`2. Reload nginx`);
  lines.push("");

  lines.push(`### Apache`);
  lines.push(`1. Place \`.htaccess\` in the web root (same folder as index.html)`);
  lines.push("");

  lines.push(`## Troubleshooting`);
  lines.push(`- If your build loads locally but fails online, it’s usually **encoding** or **wasm MIME**.`);
  lines.push(`- If you see errors like "Unexpected token" on .wasm/.data, headers are likely wrong.`);
  lines.push(`- If load is slow, ensure /Build files are cached with "immutable".`);
  lines.push("");

  return lines.join("\n");
}
